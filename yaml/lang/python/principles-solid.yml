principles:
  - title: Single Responsibility
    examples:
      - title: Good Example
        code: |
          class UserDataManager:
              def save_user_data(self):
                  pass  # Save user data logic

          class UserNotification:
              def send_notification(self):
                  pass  # Send notification logic
      - title: Bad Example
        code: |
          class User:
              def save_user_data(self):
                  pass  # Save user data logic

              def send_notification(self):
                  pass  # Send notification logic

  - title: Open-Closed
    examples:
      - title: Good Example
        code: |
          from abc import ABC, abstractmethod

          class Shape(ABC):
              @abstractmethod
              def compute_area(self):
                  pass

          class Rectangle(Shape):
              def __init__(self, width, height):
                  self.width = width
                  self.height = height

              def compute_area(self):
                  return self.width * self.height
      - title: Bad Example
        code: |
          class AreaCalculator:
              def compute_area(self, shape):
                  if isinstance(shape, Rectangle):
                      return shape.width * shape.height
                  elif isinstance(shape, Circle):
                      return 3.14 * shape.radius ** 2

  - title: Liskov Substitution
    examples:
      - title: Good Example
        code: |
          class Bird:
              def fly(self):
                  pass  # Flying logic

          class Sparrow(Bird):
              def fly(self):
                  pass  # Sparrow-specific flying logic
      - title: Bad Example
        code: |
          class Bird:
              def fly(self):
                  pass  # Flying logic

          class Ostrich(Bird):
              def fly(self):
                  raise Exception("Can't fly")  # Contradicts the expected behavior

  - title: Interface Segregation
    examples:
      - title: Good Example
        code: |
          class Worker:
              def work(self):
                  pass  # Work logic

          class Feeder:
              def eat(self):
                  pass  # Eating logic

          class Human(Worker, Feeder):
              pass

          class Robot(Worker):
              pass

          class Animal(Feeder):
              pass
      - title: Bad Example
        code: |
          class Worker:
              def work(self):
                  pass  # Work logic

              def eat(self):
                  pass  # This method should not be part of the Worker class

  - title: Dependency Inversion
    examples:
      - title: Good Example
        code: |
          from abc import ABC, abstractmethod

          class Device(ABC):
              @abstractmethod
              def turn_on(self):
                  pass

          class Switch:
              def __init__(self, device):
                  self.device = device

              def operate(self):
                  self.device.turn_on()

          class Fan(Device):
              def turn_on(self):
                  pass  # Fan-specific turn on logic

          wall_switch = Switch(Fan())
      - title: Bad Example
        code: |
          class LightBulb:
              def turn_on(self):
                  pass  # Turn on logic

          class Switch:
              def __init__(self):
                  self.bulb = LightBulb()

              def operate(self):
                  self.bulb.turn_on()
